# Credentials set in the secrets.yaml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: $device_name
    password: !secret ap_password

# I use an unprotected mqtt broker ¯\_(ツ)_/¯
mqtt:
  broker: 192.168.1.150

substitutions:
  # Must set these
  device_name: "dimmer_prototype"

  # Use the native API or MQTT, MQTT + Zigbee2MQTT is superior by 10 fold
  use_native_api: "false"
  dimming_interval: "0.25" # in seconds, native api no lower than 1, non native (mqtt) can go as low as 0.25
  mqtt_light_topic: "zigbee2mqtt/living_room/set"
  native_light_id: "light.living_room"

  # Play around with these
  default_brightness: "10" # range between 0 - 21 inclusive
  brightness_leds: "40%" # value too low can cause inconsistent color reproduction
  timeout_leds: "5s" # in seconds, time for only one led to show after a change

  # Best not touch these
  total_leds: "24"
  ring_leds: "21"
  auto_leds: "3"
  

esphome:
  name: $device_name
  platform: ESP8266
  board: esp12e
  on_boot:
    priority: -100
    then:
    # absolute hacks, otherwise LED ring won't work with addressable_set
    - script.execute: set_ring_on 
    - delay: 3s
    - script.execute: set_ring_off

captive_portal:
logger:
api:
ota:

globals:
  # Colors used in different states
  - id: color_manual
    type: int[3]
    initial_value: "{230, 204, 128}"
  - id: color_automatic
    type: int[3]
    initial_value: "{0, 0, 204}"
  - id: color_active
    type: int[3]
    initial_value: "{0, 0, 204}"

  - id: is_automatic
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: synchronize_encoder
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: ring_position
    type: int
    initial_value: "0"


status_led:
  pin:
    number: GPIO02
    inverted: true # Normally status LED is off, inverting it gives more feedback during debugging

light:
  - platform: fastled_clockless
    chipset: WS2812
    pin: GPIO13
    num_leds: $total_leds
    rgb_order: GRB
    name: "LED Ring"
    id: ring
    internal: true
    
sensor:
  - platform: homeassistant
    name: "Auto kelvin"
    id: auto_kelvin
    entity_id: input_number.kelvin
    internal: true
  - platform: homeassistant
    name: "Auto brightness"
    id: auto_brightness
    entity_id: input_number.brightness
    internal: true
    on_value:
      - script.execute: handle_auto_brightness_update

  - platform: rotary_encoder
    internal: true
    id: rotary
    name: "Rotary Encoder"
    pin_a:
      number: GPIO14
      mode: INPUT_PULLUP
    pin_b:
      number: GPIO12
      mode: INPUT_PULLUP
    min_value: 0
    max_value: $ring_leds
    filters:
      - lambda: return x * (255 / $ring_leds);
      - heartbeat: $dimming_interval s
      - delta: 1 # Prevent sending heartbeats when there are no changes
    on_value:

      # only set the lights and automations when we are not syncronizing the encoder with the auto brightness
      if:
        condition:
          lambda: 'return !id(synchronize_encoder);'
        then:
          - script.execute: send_lights
          - script.execute: send_automations

    on_raw_value:

      # if we are not syncronizing the encoder with the auto brightness, go to manual mode
      - if:
          condition:
            lambda: 'return !id(synchronize_encoder);'
          then:
            - script.execute: set_manual

      - script.execute: set_auto
      - script.execute: set_active_ring
      - script.execute: set_timed_out_ring

binary_sensor:
  - platform: gpio
    internal: true
    pin: GPIO5
    name: "Rotary switch"
    on_click:
    - min_length: 0ms
      max_length: 350ms
      then:
        - sensor.rotary_encoder.set_value:
            id: rotary
            value: !lambda "return ((id(rotary).state > 0) ? 0 : $default_brightness);"
    - min_length: 350ms
      max_length: 100000ms
      then:
        - script.execute: set_automatic
        - lambda: "id(synchronize_encoder) = true;"
        - sensor.rotary_encoder.set_value:
            id: rotary
            value: !lambda return (id(auto_brightness).state / (255 / $ring_leds));
        - lambda: "id(synchronize_encoder) = false;"


script:
  # Scripts that handle the states of the LED ring during usage
  - id: set_active_ring
    then:
      - while:
          condition:
            lambda: 'return id(rotary).raw_state != id(ring_position);'
          then:
          - light.addressable_set:
              id: ring
              red: !lambda "return id(color_active)[0];"
              green: !lambda "return id(color_active)[1];"
              blue: !lambda "return id(color_active)[2];"
              range_from: 1
              range_to: !lambda return id(ring_position);
          - light.addressable_set:
              id: ring
              red: 0
              green: 0
              blue: 0
              range_to: $ring_leds
              range_from: !lambda return id(ring_position) + 1;
          - if:
              condition:
                lambda: 'return id(rotary).raw_state > id(ring_position);'
              then:    
                - globals.set:
                    id: ring_position
                    value: !lambda return id(ring_position) + 1;
          - if:
              condition:
                lambda: 'return id(rotary).raw_state < id(ring_position);'
              then:    
                - globals.set:
                    id: ring_position
                    value: !lambda return id(ring_position) - 1;               
          - delay: 20ms
      - light.addressable_set:
          id: ring
          red: !lambda "return id(color_active)[0];"
          green: !lambda "return id(color_active)[1];"
          blue: !lambda "return id(color_active)[2];"
          range_from: 1
          range_to: !lambda return id(ring_position);
      - light.addressable_set:
          id: ring
          red: 0
          green: 0
          blue: 0
          range_to: $ring_leds
          range_from: !lambda return id(ring_position) + 1;        
  - id: set_timed_out_ring
    then:
      - script.stop: set_timed_out_ring
      - delay: $timeout_leds
      - script.execute: set_ring_off
      - light.addressable_set:
          id: ring
          red: !lambda "return id(color_active)[0];"
          green: !lambda "return id(color_active)[1];"
          blue: !lambda "return id(color_active)[2];"
          range_from: !lambda "return id(rotary).raw_state == 0 ? 1 : id(rotary).raw_state;"
          range_to: !lambda return id(rotary).raw_state;
  - id: set_auto
    then:
      - light.addressable_set:
          id: ring
          red: !lambda "return id(is_automatic) ? id(color_automatic)[0] : 0;"
          green: !lambda "return id(is_automatic) ? id(color_automatic)[1] : 0;"
          blue: !lambda "return id(is_automatic) ? id(color_automatic)[2] : 0;"
          range_from: 0
          range_to: 0
      - light.addressable_set:
          id: ring
          red: !lambda "return id(is_automatic) ? id(color_automatic)[0] : 0;"
          green: !lambda "return id(is_automatic) ? id(color_automatic)[1] : 0;"
          blue: !lambda "return id(is_automatic) ? id(color_automatic)[2] : 0;"
          range_from: 22
          range_to: 24
  # Helpers that handle communication with lights and home assistant
  - id: send_automations
    then:
      - homeassistant.service:
          service: !lambda "return id(is_automatic) ? \"automation.turn_on\" : \"automation.turn_off\";"
          data: 
            entity_id: automation.entered_sitting_area
      - homeassistant.service:
          service: !lambda "return id(is_automatic) ? \"automation.turn_on\" : \"automation.turn_off\";"
          data: 
            entity_id: automation.entered_room
      - homeassistant.service:
          service: !lambda "return id(is_automatic) ? \"automation.turn_on\" : \"automation.turn_off\";"
          data: 
            entity_id: automation.all_off_when_sleeping
  - id: send_lights
    then:
      - if:
          condition:
            lambda: "return $use_native_api;"
          then:
            - homeassistant.service:
                service: light.turn_on
                data_template:
                  entity_id: light.living_room
                  brightness: "{{ rotary | int }}"
                  transition: "$dimming_interval"
                variables:
                  rotary: |-
                    return id(rotary).state;
          else:
            - mqtt.publish_json:
                topic: !lambda return "$mqtt_light_topic";
                payload: |-
                  root["brightness"] = id(rotary).state;
                  root["transition"] = $dimming_interval;

      - logger.log:
            format: "Lights controlled: %f "
            args: [ 'id(rotary).state' ]
  - id: handle_auto_brightness_update
    then:
      if:
        condition:
          lambda: 'return id(is_automatic);'
        then:
          - lambda: "id(synchronize_encoder) = true;"
          - sensor.rotary_encoder.set_value:
              id: rotary
              value: !lambda return id(auto_brightness).state / (255 / $ring_leds);
          - delay: $dimming_interval s # Because of the debouncing we need to wait with setting this flag false
          - lambda: "id(synchronize_encoder) = false;"
  
  # Helpers for switching between manual and automatic states
  - id: set_automatic
    then:
      - lambda: "id(is_automatic) = true;"
      - lambda: "id(color_active)[0] = id(color_automatic)[0];"
      - lambda: "id(color_active)[1] = id(color_automatic)[1];"
      - lambda: "id(color_active)[2] = id(color_automatic)[2];"
  - id: set_manual
    then:
      - lambda: "id(is_automatic) = false;"
      - lambda: "id(color_active)[0] = id(color_manual)[0];"
      - lambda: "id(color_active)[1] = id(color_manual)[1];"
      - lambda: "id(color_active)[2] = id(color_manual)[2];"

  # Helpers for enabling and disabling the LED ring at boot
  - id: set_ring_off
    then:
      - light.addressable_set:
          id: ring
          red: 0
          green: 0
          blue: 0
          range_from: 0
          range_to: $total_leds
  - id: set_ring_on
    then:
      - light.turn_on:
          id: ring
          red: 0
          green: 100%
          blue: 0
          brightness: $brightness_leds

