esphome:
  name: $device_name
  platform: ESP8266
  board: esp12e
  on_boot:
    priority: -100
    then:
      - script.execute: init_dimmer    

# I use an unprotected mqtt broker ¯\_(ツ)_/¯
mqtt:
  broker: !secret mqtt_broker

# Credentials set in the secrets.yaml
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: $device_name
    password: !secret ap_password

captive_portal:
logger:
api:
ota:

globals:
  - id: color_active
    type: int[3]
    initial_value: "{0, 0, 204}"
  - id: is_automatic
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: synchronize_encoder
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: ring_position
    type: int
    initial_value: "0"

status_led:
  pin:
    number: GPIO02
    inverted: true # Normally status LED is off, inverting it gives more feedback during debugging

switch:
  - platform: restart
    internal: true
    id: dimmer_restart
    name: "Dimmer restart"

binary_sensor:
  - platform: gpio
    internal: true
    pin: GPIO0
    name: "Restart switch"
    on_release:
      then:
        - script.execute: set_ring_on
        - switch.turn_on: dimmer_restart

script:
  - id: init_dimmer
    then:
      # Hack, otherwise LED ring won't work with addressable_set
      - script.execute: set_ring_on 
      - delay: 3s
      - script.execute: set_ring_off
      - script.execute: set_automatic 
  - id: set_automatic
    then:
      - lambda: "id(is_automatic) = true;"
      - lambda: "id(color_active)[0] = id(color_automatic)[0];"
      - lambda: "id(color_active)[1] = id(color_automatic)[1];"
      - lambda: "id(color_active)[2] = id(color_automatic)[2];"
  - id: set_manual
    then:
      - lambda: "id(is_automatic) = false;"
      - lambda: "id(color_active)[0] = id(color_manual)[0];"
      - lambda: "id(color_active)[1] = id(color_manual)[1];"
      - lambda: "id(color_active)[2] = id(color_manual)[2];"